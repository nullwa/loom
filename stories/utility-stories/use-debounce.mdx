import { Meta, Markdown } from '@storybook/addon-docs/blocks'

<Meta title='utils/use-debounce' />

# use-debounce

<p>
  A React hook that debounces a value. It delays updating the value until after a specified delay time has passed since the last change. Useful for search
  inputs, API calls, or expensive computations that shouldn’t run on every keystroke.
</p>

## Features

- ⏱️ **Delay Updates**: Only update after inactivity
- 🔄 **Reusable**: Works with any type of value
- ⚡ **Performance Friendly**: Prevents excessive re-renders
- 🎯 **Type-Safe**: Fully typed with generics

## Installation

```tsx
// Copy the hook to your project
import { useDebounce } from './hooks/use-debounce'
```

## Basic Usage

```tsx
function SearchInput() {
  const [search, setSearch] = useState('')
  const debouncedSearch = useDebounce(search, 500)

  useEffect(() => {
    if (debouncedSearch) {
      console.log('Searching for:', debouncedSearch)
    }
  }, [debouncedSearch])

  return <input type='text' value={search} onChange={(e) => setSearch(e.target.value)} placeholder='Type to search...' />
}
```

## API Reference

#### **Signature**

```ts
function useDebounce<T>(value: T, delay?: number): T
```

<Markdown className='w-full'>
  {`
| Parameter | Type     | Default | Description |
|-----------|----------|---------|-------------|
| \`value\` | \`T\`      | —       | The value to debounce |
| \`delay\` | \`number\` | 500     | Delay in milliseconds before updating |
  `}
</Markdown>

#### **Return Value**

The latest **debounced value** of type `T`.

## Examples

#### **Debounced Search**

```tsx
function DebouncedSearch() {
  const [query, setQuery] = useState('')
  const debouncedQuery = useDebounce(query, 300)

  useEffect(() => {
    if (debouncedQuery) {
      console.log('Fetch API with:', debouncedQuery)
    }
  }, [debouncedQuery])

  return (
    <div>
      <input type='text' placeholder='Search...' value={query} onChange={(e) => setQuery(e.target.value)} />
      <p>Debounced value: {debouncedQuery}</p>
    </div>
  )
}
```

#### **Debouncing Window Resize**

```tsx
function WindowWidth() {
  const [width, setWidth] = useState(window.innerWidth)
  const debouncedWidth = useDebounce(width, 200)

  useEffect(() => {
    const handleResize = () => setWidth(window.innerWidth)
    window.addEventListener('resize', handleResize)
    return () => window.removeEventListener('resize', handleResize)
  }, [])

  return <p>Window width: {debouncedWidth}px</p>
}
```

## Best Practices

1. Use for **search boxes** to avoid firing API calls on every keystroke.
2. Wrap **expensive computations** like filtering or sorting.
3. Be mindful of the **delay**: too short defeats the purpose, too long hurts responsiveness.

## Troubleshooting

#### **Value Not Updating**

- Ensure you’re using the returned debounced value, not the original state.

#### **Effect Runs Too Often**

- Place logic in an effect that depends on the **debounced value**, not the raw state.
