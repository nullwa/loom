import { Meta, Markdown } from '@storybook/addon-docs/blocks'

<Meta
  title='Utils/use-breakpoint'
  parameters={{
    docs: {
      toc: {
        contentsSelector: '.sbdocs-content',
        headingSelector: 'h1, h2, h3, h4',
        ignoreSelector: '#primary',
        title: 'Table of Contents',
        disable: false,
      },
    },
  }}
/>

# use-breakpoint

<p>
A React hook to detect if the current viewport matches a Tailwind CSS breakpoint.  
Returns a boolean indicating whether the viewport width is equal to or greater than the specified breakpoint.

This hook uses the modern `matchMedia` API with proper SSR support and automatic cleanup.

</p>

## Features

- üéØ **Tailwind Integration**: Uses default Tailwind CSS breakpoints
- üì± **Responsive Design**: Perfect for conditional rendering based on screen size
- üîÑ **Real-time Updates**: Automatically updates when viewport changes
- üñ•Ô∏è **SSR Safe**: Handles server-side rendering without hydration issues
- üßπ **Auto Cleanup**: Removes event listeners on unmount
- ‚ö° **Performant**: Uses native `matchMedia` API

## Installation

```tsx
// Copy the hook to your project
import { useBreakpoint } from './hooks/useBreakpoint'
```

## Basic Usage

```tsx
function ResponsiveComponent() {
  const isLarge = useBreakpoint('lg')
  const isMobile = !useBreakpoint('sm')

  return <div>{isLarge ? <div>Desktop Layout</div> : <div>Mobile Layout</div>}</div>
}
```

## API Reference

#### **Parameters**

<Markdown>
  {`
| Parameter | Type | Required | Description |
|-----------|------|----------|-------------|
| \`size\` | \`'sm' \\| 'md' \\| 'lg' \\| 'xl' \\| '2xl'\` | Yes | Tailwind CSS breakpoint to match |
  `}
</Markdown>

#### **Return Value**

Returns `boolean` - `true` if viewport width is equal to or greater than the breakpoint.

#### **Breakpoint Values**

<Markdown>
  {`
| Breakpoint | Min Width | Description |
|------------|-----------|-------------|
| \`sm\` | 640px | Small devices (phones) |
| \`md\` | 768px | Medium devices (tablets) |
| \`lg\` | 1024px | Large devices (laptops) |
| \`xl\` | 1280px | Extra large devices (desktops) |
| \`2xl\` | 1536px | 2X large devices (large desktops) |
  `}
</Markdown>

## Examples

#### **Conditional Rendering**

```tsx
function NavigationMenu() {
  const isDesktop = useBreakpoint('lg')

  return <nav>{isDesktop ? <HorizontalMenu /> : <HamburgerMenu />}</nav>
}
```

#### **Multiple Breakpoints**

```tsx
function ResponsiveGrid() {
  const isSm = useBreakpoint('sm')
  const isMd = useBreakpoint('md')
  const isLg = useBreakpoint('lg')
  const isXl = useBreakpoint('xl')

  const getGridCols = () => {
    if (isXl) return 'grid-cols-4'
    if (isLg) return 'grid-cols-3'
    if (isMd) return 'grid-cols-2'
    return 'grid-cols-1'
  }

  return (
    <div className={`grid gap-4 ${getGridCols()}`}>
      {items.map((item) => (
        <Card key={item.id} {...item} />
      ))}
    </div>
  )
}
```

#### **Custom Hook Composition**

```tsx
function useResponsiveValue<T>(values: { sm?: T; md?: T; lg?: T; xl?: T; '2xl'?: T; default: T }): T {
  const isSm = useBreakpoint('sm')
  const isMd = useBreakpoint('md')
  const isLg = useBreakpoint('lg')
  const isXl = useBreakpoint('xl')
  const is2xl = useBreakpoint('2xl')

  if (is2xl && values['2xl']) return values['2xl']
  if (isXl && values.xl) return values.xl
  if (isLg && values.lg) return values.lg
  if (isMd && values.md) return values.md
  if (isSm && values.sm) return values.sm

  return values.default
}

// Usage
function MyComponent() {
  const columns = useResponsiveValue({
    sm: 1,
    md: 2,
    lg: 3,
    xl: 4,
    default: 1,
  })

  return <div>Showing {columns} columns</div>
}
```

#### **Responsive Component Visibility**

```tsx
function ResponsiveComponents() {
  const isMobile = !useBreakpoint('md')
  const isTablet = useBreakpoint('md') && !useBreakpoint('lg')
  const isDesktop = useBreakpoint('lg')

  return (
    <div>
      {isMobile && <MobileOnlyComponent />}
      {isTablet && <TabletOnlyComponent />}
      {isDesktop && <DesktopOnlyComponent />}

      {/* Always visible with different props */}
      <SharedComponent compact={isMobile} showSidebar={isDesktop} />
    </div>
  )
}
```

#### **Media Query Hook Alternative**

```tsx
function useMediaQuery(query: string): boolean {
  const [matches, setMatches] = useState(() => (typeof window !== 'undefined' ? window.matchMedia(query).matches : false))

  useEffect(() => {
    const mediaQuery = window.matchMedia(query)
    setMatches(mediaQuery.matches)

    const handleChange = (event: MediaQueryListEvent) => {
      setMatches(event.matches)
    }

    mediaQuery.addEventListener('change', handleChange)
    return () => mediaQuery.removeEventListener('change', handleChange)
  }, [query])

  return matches
}

// Usage with custom breakpoints
function CustomBreakpointComponent() {
  const isCustomSize = useMediaQuery('(min-width: 900px)')
  const isLandscape = useMediaQuery('(orientation: landscape)')

  return <div>{isCustomSize && isLandscape && <SpecialLayout />}</div>
}
```

## Configuration

#### **Custom Breakpoints**

You can modify the `SCREENS` constant to match your Tailwind configuration:

```tsx
const SCREENS: Record<'sm' | 'md' | 'lg' | 'xl' | '2xl', string> = {
  sm: '480px', // Custom small breakpoint
  md: '768px',
  lg: '1024px',
  xl: '1280px',
  '2xl': '1536px',
}
```

#### **TypeScript Support**

The hook is fully typed with Tailwind breakpoint names:

```tsx
const isLarge = useBreakpoint('lg') // ‚úÖ Valid
const isInvalid = useBreakpoint('xs') // ‚ùå TypeScript error
```

## SSR Considerations

<p>The hook is designed to work with server-side rendering:</p>

- **Initial State**: Returns `true` by default on the server to prevent layout shifts
- **Hydration**: Updates immediately on the client with the correct value
- **No Flash**: Prevents content jumping when hydrating

#### **Custom SSR Defaults**

If you need different SSR behavior, you can modify the initial state:

```tsx
const [matches, setMatches] = useState(
  () => (typeof window !== 'undefined' ? window.matchMedia(`(min-width: ${SCREENS[size]})`).matches : false) // Change to false for mobile-first SSR
)
```

## Browser Support

- **Modern browsers**: Full support with `matchMedia` API
- **Legacy browsers**: Graceful degradation (IE 10+)
- **Node.js/SSR**: Safe handling when `window` is undefined

## Performance Considerations

- **Single Event Listener**: Each hook instance creates its own optimized listener
- **Automatic Cleanup**: Prevents memory leaks by removing listeners on unmount
- **Efficient Updates**: Only re-renders when the breakpoint actually changes
- **Minimal Bundle**: Uses native browser APIs, no external dependencies

## Best Practices

1. **Avoid Overuse**: Don't use multiple breakpoints when CSS media queries would suffice
2. **Combine Wisely**: Use with CSS classes for optimal performance
3. **SSR Aware**: Consider the SSR default behavior in your designs
4. **Debounce if Needed**: For expensive operations, consider debouncing the results

## Troubleshooting

#### **Hook Not Updating**

- Check that the component is properly mounted
- Verify the breakpoint name is correct (`'lg'` not `'large'`)
- Ensure the component re-renders when the hook value changes

#### **SSR Hydration Issues**

- The hook defaults to `true` on the server to prevent layout shifts
- If you experience hydration mismatches, consider using `useEffect` to delay rendering

#### **Performance Issues**

- Multiple breakpoint hooks are efficient, but consider consolidating logic
- For complex responsive logic, create custom composite hooks

## Related Hooks

- `useMediaQuery` - For custom media queries beyond Tailwind breakpoints
- `useWindowSize` - For getting exact window dimensions
- `useViewport` - For viewport-related calculations
